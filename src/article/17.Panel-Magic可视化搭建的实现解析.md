## 介绍

[Panel-Magic](https://github.com/Ricbet/panel-magic) 是一个基于 AngularX+ 并面向设计师或运营人员的可视化搭建平台，目前仅可用于快速生成微信小程序应用，具有与 Photoshop 相似的交互体验！！

> 好了，吹完之后接下来开始从技术角度剖析我在做这个搭建平台时和实现原理

在此之前说明该平台的定位，目的不是给技术人员编辑完之后进行二次开发或代码的定制化。关于这个定位问题我个人的想法是，code 问题不可能完全交托给可视化编辑、除非是类似传统的企业介绍页等还有可能完全代替，但还是比不上直接代码生成的工具，所以 Panel-Magic 一开始的定位就是给设计师或运营人员使用，生成的产物不再是 code。

## 技术栈

-   框架选型：Angular8
-   UI 组件库：[ng-zorro-antd](https://github.com/NG-ZORRO/ng-zorro-antd)(宇宙第一组件库)
-   本地存储：IndexedDB
-   响应式编程库：Rxjs
-   编写语言：Typescript
-   CSS 预处理器：SCSS
-   最终产物：JSON

## 工作流程

![1.png](../assets/img/17/1.svg)

关键是中间的数据模型的建模过程以及可视化界面的创建，生成的新数据和源数据都是约定好固定格式的 JSON 描述文件，其包含固定的 key 字段和对应的 value 值类型，生成小程序的过程在生成完新数据之后

目前源数据约定的数据格式为

```JSON
{
    "app_id": "",
    "cata_data": [
        {
            "group": "默认组",
            "pages": [
                {
                    "title": "首页",
                    "name": "首页",
                    "router": "page10001",
                    "isEdit": false,
                    "uniqueId": 1556693791081,
                },
            ],
            "isEdit": false,
            "uniqueId": 1556693791066,
        }
    ]
    // more ...
}
```

更为完整的约定格式在 [MockModel.ts](https://github.com/Ricbet/panel-magic/blob/master/src/app/service/hs-xcx/MockModel.ts)

## 目录结构

```termianle
src
├── app
│   ├── appdata                                 // AppData 根服务，数据模型 AppDataModel 的核心服务
│   ├── base-class                              // 基类
│   ├── core                                    // HttpClient 服务
│   ├── panel-extend                            // 可视化搭建交互部分
│   │   ├── model                               // 数据模型
│   │   ├── panel-assist-arbor                  // 右侧可操作区域如对齐、图层、前进后退等操作入口
│   │   ├── panel-catalogue                     // 页面分组管理
│   │   ├── panel-event                         // 事件管理
│   │   ├── panel-layer                         // 图层列表管理
│   │   ├── panel-scaleplate                    // 标尺管理
│   │   ├── panel-scope-enchantment             // 核心拖拽部分
│   │   ├── panel-senior-vessel-edit            // 容器组合管理
│   │   ├── panel-shell                         // “手机壳”区域管理
│   │   ├── panel-soul                          // 左侧组件库管理
│   │   ├── panel-widget                        // 每个部分组件如按钮、文字等
│   │   │   ├── all-widget-container
│   │   │   │   ├── auxiliaryline-widget
│   │   │   │   ├── button-widget
│   │   │   │   ├── linkrange-widget
│   │   │   │   ├── picture-widget
│   │   │   │   ├── rect-widget
│   │   │   │   └── text-widget
│   │   │   ├── all-widget-unit
│   │   │   │   ├── map-view
│   │   │   │   ├── navigation-bar-view
│   │   │   │   ├── rich-text-view
│   │   │   │   ├── slideshow-picture-view
│   │   │   │   └── tab-bar-view
│   │   │   ├── all-widget-vessel
│   │   │   │   └── senior-vessel-widget
│   │   │   └── model
│   │   ├── panel-widget-appearance             // “设置”管理
│   │   │   ├── model
│   │   │   ├── panel-widget-animation
│   │   │   ├── panel-widget-clip-path
│   │   │   ├── panel-widget-facade
│   │   │   ├── panel-widget-filter
│   │   │   ├── panel-widget-picture
│   │   │   ├── panel-widget-shadow
│   │   │   └── panel-widget-text
│   │   ├── panel-widget-appearance-site        // 每个部分组件的专属“设置”
│   │   │   ├── panel-button-site
│   │   │   ├── panel-combination-site
│   │   │   ├── panel-line-site
│   │   │   ├── panel-linkrange-site
│   │   │   ├── panel-map-site
│   │   │   ├── panel-picture-site
│   │   │   ├── panel-rect-site
│   │   │   ├── panel-slideshow-picture-site
│   │   │   └── panel-text-site
│   │   └── panel-widget-details                // 弹出来的“设置”管理界面
│   ├── public                                  // 公共组件
│   │   ├── directive
│   │   ├── image-gallery
│   │   ├── my-color-picker
│   │   ├── ng-thumb-auto
│   │   ├── pipe
│   │   ├── theme
│   │   ├── top-navbar
│   │   └── util
│   ├── service                                 // 服务端 service
│   │   ├── hs-files
│   │   └── hs-xcx
│   └── share
├── assets                                      // 资源文件
```

## 布局排版

为了实现更好的自由布局排版，在不考虑代码生成的情况下，绝对定位是我的首选选择，也更能适配像素级别的定制编辑

除了定位数据以外，每个组件其实都具有通用的样式数据，如边框设置、阴影设置、文本设置、定位设置等通用元素，甚至也具有通用的事件设置，然后对于编辑来说，组件同时也具有如选中时的轮廓样式数据等，所以我们定义一个基本组件数据模型，让所有组件都继承这个模型 [PanelWidgetModel.ts](https://github.com/Ricbet/panel-magic/blob/master/src/app/panel-extend/panel-widget/model/panel-widget.model.ts)

拿 button 按钮组件举例来说，它位于 `src/app/panel-extend/panel-widget/all-widget-container/button-widget`;

```
├── button-widget.component.html
├── button-widget.component.ts
└── button-widget.data.ts
```

> 其中 `button-widget.data.ts` 文件是用于在左侧拖拽组件到中间编辑区域时候的默认样式和事件数据，它是直接实例化了 PanelWidgetModel 并导出

其中 component 为；

```Typescript
import { Component, OnInit, Input } from "@angular/core";
import { PanelWidgetModel } from "../../model";

@Component({
    selector: "app-button-widget",
    templateUrl: "./button-widget.component.html",
    styles: [""],
})
export class ButtonWidgetComponent implements OnInit {
    private _widget: PanelWidgetModel;

    @Input()
    public get widget(): PanelWidgetModel {
        return this._widget;
    }
    public set widget(v: PanelWidgetModel) {
        this._widget = v;
    }
    constructor() {}

    ngOnInit() {}
}

```

然后在渲染的时候双向绑定里面的文本数据

```html
<p *ngIf="!widget.isHiddenText" class="text-overflow-hidden">{{ widget.autoWidget.content }}</p>
```

对于简单的组件 `PanelWidgetModel` 提供的基本数据模型足矣；

稍微复杂的组件如 `map` 地图组件则可以在 component 文件里自行拓展 PanelWidgetModel 类；

有了 `PanelWidgetModel` 之后，我们来看看渲染组件的核心代码部分 👇;

```html
<div class="zoom-area" [ngStyle]="{ 'background-color': panelInfo.bgColor }">
    <ng-container *ngFor="let widget of widgetList$ | async">
        <div class="widget-shell" [ngStyle]="widget.profileModel.styleContent">
            <app-panel-widget [widget]="widget" [isSimpleFunc]="false"></app-panel-widget>
        </div>
    </ng-container>
</div>
```

在模版中循环异步渲染 `widgetList$` 里的组件并传递数据给 app-panel-widget 组件;

其中 `widgetList$` 定义为;

```typescript
public get widgetList$(): BehaviorSubject<Array<PanelWidgetModel>> {
    return this.panelExtendService.widgetList$;
}

// 在 panelExtendService 服务里
public widgetList$: BehaviorSubject<Array<PanelWidgetModel>> = new BehaviorSubject<Array<PanelWidgetModel>>([]);
```

就是上述提到的 PanelWidgetModel 类列表；

而 app-panel-widget 组件位于 `src/app/panel-extend/panel-widget/panel-widget.component.ts`

它负责接收 `widgetList$` 里的每一个不同组件并根据 `type` 类型负责渲染对应的组件；

```html
<div
    class="widget-main"
    [nrIsStopPropagation]="true"
    nrDraggable
    [nrIdBody]="'#free-panel-main'"
    (launchMouseIncrement)="acceptDraggableIncrement($event)"
    nrMouseMoveOut
    (dblclick)="acceptDoubleClick()"
    (mousedown)="acceptWidgetChecked($event)"
    (emitMouseType)="acceptMouseMoveOut($event)"
    (contextmenu)="acceptWidgetRightClick($event)"
>
    <ng-container *ngIf="widget.autoWidget">
        <div class="widget-content {{ widget.type }}" *ngIf="widget.type != 'combination'" [ngStyle]="widgetStyle">
            <ng-container [ngSwitch]="widget.type">
                <!-- 文本 -->
                <ng-container *ngSwitchCase="'text'">
                    <app-text-widget [widget]="widget"></app-text-widget>
                </ng-container>
                <!-- 图片 -->
                <ng-container *ngSwitchCase="'picture'">
                    <app-picture-widget [widget]="widget"></app-picture-widget>
                </ng-container>
                <!-- 按钮 -->
                <ng-container *ngSwitchCase="'button'">
                    <app-button-widget [widget]="widget"></app-button-widget>
                </ng-container>
                <!-- 辅助线 -->
                <ng-container *ngSwitchCase="'line'">
                    <app-auxiliaryline-widget [widget]="widget"></app-auxiliaryline-widget>
                </ng-container>
                <!-- 矩形 -->
                <ng-container *ngSwitchCase="'rect'"></ng-container>
                <!-- 链接区域 -->
                <ng-container *ngSwitchCase="'linkrange'">
                    <app-linkrange-widget [widget]="widget"></app-linkrange-widget>
                </ng-container>
                <!-- 轮播图 -->
                <ng-container *ngSwitchCase="'slideshowpicture'">
                    <app-slideshow-picture-view [widget]="widget"></app-slideshow-picture-view>
                </ng-container>
                <!-- 富文本 -->
                <ng-container *ngSwitchCase="'richtext'">
                    <app-rich-text-view [autoWidget]="widget"></app-rich-text-view>
                </ng-container>
                <!-- 地图 -->
                <ng-container *ngSwitchCase="'map'">
                    <app-map-view [autoWidget]="widget"></app-map-view>
                </ng-container>
                <!-- 动态容器 -->
                <ng-container *ngSwitchCase="'seniorvessel'">
                    <div class="vessel-tip" *ngIf="isViseableVesselTip"><span>双击编辑动态容器</span></div>
                    <app-senior-vessel-widget [widget]="widget"></app-senior-vessel-widget>
                </ng-container>
            </ng-container>
        </div>
        <!-- 组合 -->
        <ng-container *ngIf="widget.type == 'combination'">
            <div class="combination-container" [ngStyle]="widgetStyle">
                <ng-container *ngFor="let list of widget.autoWidget.content">
                    <ng-container
                        *ngIf="list.type != 'combination' && (list.profileModel.combinationWidgetData$ | async)"
                    >
                        <div
                            class="widget-shell"
                            [ngStyle]="(list.profileModel.combinationWidgetData$ | async).styleContent"
                        >
                            <app-panel-widget [widget]="list" [isSimpleFunc]="true"></app-panel-widget>
                        </div>
                    </ng-container>
                </ng-container>
            </div>
        </ng-container>
    </ng-container>
</div>
```

完了之后剩下的就是各个组件单独处理自己内部的实现了;

我们继续看 app-panel-widget 组件的模版实现部分;

它负责接收的事件有;

```html
<div
    class="widget-main"
    [nrIsStopPropagation]="true"
    nrDraggable
    [nrIdBody]="'#free-panel-main'"
    (launchMouseIncrement)="acceptDraggableIncrement($event)"
    nrMouseMoveOut
    (dblclick)="acceptDoubleClick()"
    (mousedown)="acceptWidgetChecked($event)"
    (emitMouseType)="acceptMouseMoveOut($event)"
    (contextmenu)="acceptWidgetRightClick($event)"
></div>
```

-   `nrDraggable`: 指定该组件是可拖拽组件
-   `launchMouseIncrement`: 由 public 里的 DraggableDirective 指令提供，用于返回鼠标事件的 movementY 和 movementX
-   `nrMouseMoveOut`: 由 public 里的 MousemoveoutDirective 指令提供，用于返回鼠标的移入和移出事件监听
-   `emitMouseType`: 由 public 里的 MousemoveoutDirective 指令提供，返回鼠标是移入还是移出事件
-   `contextmenu`: 右键事件

所以，当你在面板中选中某个组件的时候，不单单只是一个简单的 click 事件组成，是由鼠标的移入、鼠标按下、鼠标弹起等分解步骤来完成；

我们先看看 `mousedown` 事件, 它执行的方法为 `acceptWidgetChecked`；

```typescript
public acceptWidgetChecked(event: MouseEvent): void {
    if (!this.isSimpleFunc) {
        event.stopPropagation();
        event.preventDefault();
        if (
            !this.panelScopeEnchantmentService.scopeEnchantmentModel.outerSphereInsetWidgetList$.value.some(
                w => w.uniqueId == this.widget.uniqueId
            )
        ) {
            event.shiftKey == true
                ? this.panelScopeEnchantmentService.toggleOuterSphereInsetWidget(this.widget)
                : this.panelScopeEnchantmentService.onlyOuterSphereInsetWidget(this.widget);
        } else {
            if (event.shiftKey == true) this.panelScopeEnchantmentService.toggleOuterSphereInsetWidget(this.widget);
        }
        this.openMouseMoveLaunch();
    }
}
```

我先解释一下，这里当鼠标按下的时候是会生成轮廓组件 ``

## 辅助线生成规则

## 选中、多选、组合和旋转拉伸

## 前进和后退

## 剪贴蒙版

## 动态容器

## 关于如何生成小程序
