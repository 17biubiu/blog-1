[code-server](https://github.com/cdr/code-server/tree/2.1692-vsc1.39.2) 是一个开源的在线 vscode 远端运行服务，本文从源码角度来解读他是如何把 vscode 搬到浏览器运行的

> vscode 版本 1.39.2 </br>
> node 版本 10.16.0

### 先预热一下 vscode 架构

![1.png](../assets/img/14/1.png)

作为本地的 Electron 应用，他采用的是多进程架构;

主进程和很多子进程之间进行 IPC 通信或 RPC 远程过程调用，其中插件系统也作为了一个进程，所有的插件都会在这个进程下运行，包括语言服务协议等;

debug 协议与其他进程不同，每次执行 debug 都会新开一个子进程;

其中较为常见的文件读写都是在 main 主进程中完成;

### coder 开发流程

在 coder-server 的 README 里有开发流程步骤，大抵上分为

```shell
git clone https://github.com/microsoft/vscode
cd vscode
git checkout ${vscodeVersion} # See travis.yml for the version to use.
yarn
git clone https://github.com/cdr/code-server src/vs/server
cd src/vs/server
yarn
yarn patch:apply
yarn watch
# Wait for the initial compilation to complete (it will say "Finished compilation").
# Run the next command in another shell.
yarn start
# Visit http://localhost:8080
```

1. 先 `clone` vscode 项目并切换到某固定版本
2. 把自己 `clone` 到 `src/vs/server` 目录下
3. 把魔改的部分通过补丁 `patch` 打进 vscode，执行 `watch` 将 vscode 项目里的 ts 代码编译成可执行的 js 文件并输出到 out 目录
4. start 其实就是用 node 跑 out/vs/server/main.js 文件

所以我们可以认为他完全是充当了 vscode 的 server 端，为其 web 版提供支持能力，重点就是在 patch 补丁部分

### 目录

```tree
scripts
├── build.ts                        // 主要的 build 脚本文件，分为 build、binary、package 和 ensure-in-vscode 四种 task
├── ci.bash                         // 用于跑 CI 构建流程，分为 docker-build 和 local-build
├── ci.dockerfile
├── optimize.js
├── package.json
├── product.json
├── tsconfig.json
└── vscode.patch                    // 针对 vscode 1.39.2 版本打的 git patch 文件
src
├── browser                         // 主要是 client 端的实现
│   ├── api.ts                      // vscode 客户端的 api 实现
│   ├── client.ts                   // 客户端初始化执行
│   ├── extHostNodeProxy.ts         // 插件代理，通过补丁打在了 src/vs/workbench/services/extensions/worker/extHost.services.ts 目录作为单例服务，进行 rpc 远程过程调用
│   ├── login.html                  // 登陆授权
│   ├── mainThreadNodeProxy.ts      // 主线程代理
│   ├── upload.ts                   // 上载服务，拖动文件在文件树就执行该服务
│   ├── workbench-build.html
│   ├── workbench.html              // 入口 html 文件
│   └── worker.ts                   // 复写 src/vs/workbench/api/worker/extHostExtensionService.ts 目录下 _loadCommonJSModule 方法，其中关键用到 coder 自己封装的 node-browser 和 requirefs，为浏览器提供诸如 fs、net、require 的能力
├── common                          // server 端和 client 端都可使用的服务
│   ├── nodeProxy.ts                // 代理隧道服务
│   ├── telemetry.ts                // 遥测隧道服务
│   └── util.ts
├── media
│   ├── code-server.png
│   ├── favicon.ico
│   ├── login.css
│   └── manifest.json
└── node                            // 服务端 server 实现
    ├── channel.ts                  // 主要
    ├── cli.ts
    ├── connection.ts
    ├── insights.ts
    ├── ipc.ts
    ├── marketplace.ts
    ├── nls.ts
    ├── protocol.ts
    ├── server.ts
    ├── update.ts
    ├── uriTransformer.js
    └── util.ts
typings
├── api.d.ts    
├── httpolyglot.d.ts
└── package.json
```

### 启动顺序

在 server 目录下执行 start 命令其实就是用 node 跑 `out/vs/server/main.js` 文件

main 文件核心就一行

> require("../../bootstrap-amd").load("vs/server/src/node/cli");

通过 amd 模块加载 cli 文件，而这个 cli 文件就是位于 server/node/cli;

该文件执行 <span id="main">main</span> 函数
```typescript
const main = async(): Promise<boolean | void | void[]> => {
	const args = getArgs();
	if (process.env.LAUNCH_VSCODE) {
		await ipcMain.handshake();
		return startVscode(args);
	}
	return startCli(args) || new WrapperProcess(args).start();
};
```

这一步开始其实 process.env.LAUNCH_VSCODE 环境变量初始为空，startCli 函数其实里面也是根据环境参数做一些判断，但初始都是返回 false，关键是这个 `WrapperProcess`;

实例化 `WrapperProcess` 的时候便开始进行 ipc 的 `onMessage` 监听，用于进程之间的通信，完了之后执行 start 函数

```typescript
if (!this.started) {
    const child = this.spawn();
    this.started = ipcMain.handshake(child).then(() => {
        child.once("exit", (code) => exit(code!));
    });
    this.process = child;
}
return this.started;
```

通过 spawn 创建了子进程并进入 ipc 的握手阶段，此时把当前进程替换到了主进程, 而其中 spawn 做了以下事情

```typescript
//...
const isBinary = (global as any).NBIN_LOADED;
return cp.spawn(process.argv[0], process.argv.slice(isBinary ? 2 : 1), {
    env: {
        ...process.env,
        LAUNCH_VSCODE: "true",
        NBIN_BYPASS: undefined,
        VSCODE_PARENT_PID: process.pid.toString(),
        NODE_OPTIONS: nodeOptions,
    },
    stdio: ["inherit", "inherit", "inherit", "ipc"],
});
```

> NBIN_LOADED 环境其实是 coder 自定义的，[nbin](https://github.com/cdr/nbin) 主要是通过给 node 的 fs 模块打补丁一顿魔改达到增强二进制编译的过程，这也是为啥会对 node 版本具有强约束性的原因（骚。。。

使用当前的所有参数重新创建了一个子进程并返回，其中 stdio 指定了 ipc 通道，LAUNCH_VSCODE 环境变量也设置为了 true，此时 `main` 函数被`重新执行`了;

回到 <a href="#main">main</a> 这里, 此时直接等待 ipc 握手之后运行 startVscode;

```typescript
//...

const server = new MainServer({
    ...options,
    port: typeof args.port !== "undefined" ? parseInt(args.port, 10) : 8080,
    socket: args.socket,
}, args);

const [serverAddress, /* ignore */] = await Promise.all([
    server.listen(),
    unpackExecutables(),
]);

//...
```

可以总结为，cli 其实就是建立 ipc 通道并预处理一大堆参数从而启动 server 的过程;

### Server 端

来到 server 端的 MainServer 函数，它继承了抽象类 Server，并在构造函数里启动 http 服务

```typescript
public constructor(options: ServerOptions) {
    this.options = {
        host: options.auth === "password" && options.cert ? "0.0.0.0" : "localhost",
        ...options,
        basePath: options.basePath ? options.basePath.replace(/\/+$/, "") : "",
        password: options.password ? hash(options.password) : undefined,
    };
    this.protocol = this.options.cert ? "https" : "http";
    if (this.protocol === "https") {
        const httpolyglot = localRequire<typeof import("httpolyglot")>("httpolyglot/lib/index");
        this.server = httpolyglot.createServer({
            cert: this.options.cert && fs.readFileSync(this.options.cert),
            key: this.options.certKey && fs.readFileSync(this.options.certKey),
        }, this.onRequest);
    } else {
        this.server = http.createServer(this.onRequest);
    }
}
```

其中 cert 参数做了自签名证书处理，我猜测是为了安全考虑吧。。

onRequest 方法里对请求头做了预处理

```typescript
//...
const payload = await this.preHandleRequest(request, parsedUrl);
//...
```

preHandleRequest 方法里对请求的路径做了一通拦截处理，其中有一段

```typescript
// Allow for a versioned static endpoint. This lets us cache every static
// resource underneath the path based on the version without any work and
// without adding query parameters which have their own issues.
// REVIEW: Discuss whether this is the best option; this is sort of a quick
// hack almost to get caching in the meantime but it does work pretty well.
if (/^\/static-/.test(base)) {
    base = "/static";
}
```

通过正则匹配所有路径里开头含有 `static-` 的文件将 base 路径重置为 /static ，为了后面做缓存处理

```typescript
//...
case "/static":
    const response = await this.getResource(this.rootPath, requestPath);
    response.cache = true;
    return response;
//...
```

其中 getResource 就是直接读文件内容并返回

```typescript
protected async getResource(...parts: string[]): Promise<Response> {
    const filePath = this.ensureAuthorizedFilePath(...parts);
    return { content: await util.promisify(fs.readFile)(filePath), filePath };
}
```

除了 static 路径和特定的几个资源文件路径其余的文件都向下走 handleRequest 函数;
这里面就是处理各种文件资源请求的方式，譬如有对 tar 文件格式资源的处理和 webview 文件资源处理还有静态资源的处理等，当然里面还有 heartbeat 心跳;

此时 Server 抽象类的主要任务完成了，剩下的交给 MainServer，其构造函数里先执行 initializeServices 方法；

